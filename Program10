Aim: To implement Dijkstra’s and Bloom Filter.
Program: Write a program to implement shortest path algorithm (Dijkstra’s) using heapq and advanced data structure (Bloom Filter) with multiple hash functions (hashlib) for membership.
	Test with
	Test Dijkstra’s with graph: nodes [A, B, C, D], edges [A-B:4, A-C:2, B-D:5, C-D:8].
	Test Bloom filter with: insert [apple, banana], query [apple, orange].

Description:

1. Dijkstra's Shortest Path Algorithm
This program implements Dijkstra's algorithm in Java to find shortest paths from a source node to all other nodes in a weighted graph. The implementation uses:
•	Priority Queue (Min-Heap): Efficiently selects the node with minimum distance at each step
•	Adjacency List: Stores graph with edge weights using HashMap of Edge lists
•	Distance Tracking: Maintains shortest distances and updates them when better paths are found
•	Greedy Approach: Always explores the closest unvisited node first
The program is tested with nodes [A, B, C, D] and weighted edges [A-B:4, A-C:2, B-D:5, C-D:8]. Starting from node A, Dijkstra's algorithm computes shortest paths: A→A=0, A→B=4, A→C=2, A→D=9 (via A→B→D), demonstrating optimal path finding.

2. Bloom Filter for Membership Testing
This program implements a Bloom Filter in Java, a space-efficient probabilistic data structure for membership testing. The implementation includes:
•	Bit Array: Fixed-size boolean array to store membership information
•	Multiple Hash Functions: Uses different seed values to generate independent hash values for each item
•	Insert Operation: Sets multiple bits in the array based on hash values
•	Query Operation: Checks if all corresponding bits are set (returns "possibly in set" or "definitely not in set")
•	No False Negatives: If item was inserted, query always returns true; may have false positives
The program is tested with a filter of size 100 and 3 hash functions. Items ["apple", "banana"] are inserted, and queries for "apple" (inserted) and "orange" (not inserted) demonstrate that "apple" returns "possibly in set" while "orange" returns "definitely not in set".

Code:
import heapq
import hashlib
print("P.Manoj cse-c 24241")

# ---------- Dijkstra's Algorithm ----------
def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    pq = [(0, start)]  # (distance, node)

    while pq:
        current_distance, current_node = heapq.heappop(pq)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances

# ---------- Bloom Filter ----------
class BloomFilter:
    def __init__(self, size=20):
        self.size = size
        self.bit_array = [0] * size

    def _hashes(self, item):
        # Multiple hash functions using hashlib
        hash1 = int(hashlib.md5(item.encode()).hexdigest(), 16) % self.size
        hash2 = int(hashlib.sha1(item.encode()).hexdigest(), 16) % self.size
        return [hash1, hash2]

    def add(self, item):
        for h in self._hashes(item):
            self.bit_array[h] = 1

    def check(self, item):
        return all(self.bit_array[h] == 1 for h in self._hashes(item))

# ---------- Main Program ----------
if __name__ == "__main__":
    print("=== Dijkstra's Algorithm ===")
    n = int(input("Enter number of nodes: "))
    graph = {}

    for _ in range(n):
        node = input("Enter node name: ")
        graph[node] = []

    e = int(input("Enter number of edges: "))
    for _ in range(e):
        src = input("From node: ")
        dest = input("To node: ")
        weight = int(input("Weight: "))
        graph[src].append((dest, weight))
        graph[dest].append((src, weight))  # Undirected

    start = input("Enter start node: ")
    result = dijkstra(graph, start)
    print("\nShortest distances from", start, ":")
    for node, dist in result.items():
        print(f"{node}: {dist}")

    # ---------- Bloom Filter Testing ----------
    print("\n=== Bloom Filter ===")
    bf = BloomFilter()

    items_to_add = input("Enter items to insert (comma separated): ").split(",")
    for item in items_to_add:
        bf.add(item.strip())

    items_to_check = input("Enter items to check (comma separated): ").split(",")
    for item in items_to_check:
        found = bf.check(item.strip())
        print(f"{item.strip()} -> {'Possibly present' if found else 'Not present'}")
