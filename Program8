Aim: To implement B-Tree. 
Program: Write a Program to implement B-Trees of order m=3 with Insert and Search Operations.
	Test with: 
	insert [10, 20, 5, 6, 12, 30]
	Search 6.
Description:
B-Tree Implementation (Order m=3)
This program implements a B-Tree data structure in Python with order m=3 (minimum degree t=2), which is a self-balancing tree optimized for systems that read/write large blocks of data. The BTree class provides:
•	Node Structure: Each node contains keys, child pointers, leaf status, and current key count
•	Insert: Adds keys while maintaining B-tree properties; splits nodes when full (contains 2t-1 keys)
•	Search: Traverses tree by comparing key with node keys and moving to appropriate child
•	Split Child: Divides full child nodes and promotes median key to parent
•	Properties: All leaves at same level, nodes contain between t-1 and 2t-1 keys (except root)
The program is tested by inserting [10, 20, 5, 6, 12, 30], which creates a balanced B-tree structure with automatic node splits when capacity is exceeded, followed by searching for key 6.







Code:
print("P.Manoj cse-c 24241")
class BTreeNode:
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []

class BTree:
    def __init__(self, t=3):
        self.root = BTreeNode(True)
        self.t = t  # Order of B-Tree

    # Search key in the B-Tree
    def search(self, node, key):
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and node.keys[i] == key:
            return True

        if node.leaf:
            return False
        else:
            return self.search(node.children[i], key)

    # Insert a new key
    def insert(self, key):
        root = self.root
        if len(root.keys) == (2 * self.t) - 1:
            temp = BTreeNode()
            self.root = temp
            temp.children.insert(0, root)
            self.split_child(temp, 0)
            self.insert_non_full(temp, key)
        else:
            self.insert_non_full(root, key)

    def insert_non_full(self, node, key):
        i = len(node.keys) - 1
        if node.leaf:
            node.keys.append(0)
            while i >= 0 and key < node.keys[i]:
                node.keys[i + 1] = node.keys[i]
                i -= 1
            node.keys[i + 1] = key
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            if len(node.children[i].keys) == (2 * self.t) - 1:
                self.split_child(node, i)
                if key > node.keys[i]:
                    i += 1
            self.insert_non_full(node.children[i], key)

    def split_child(self, node, i):
        t = self.t
        y = node.children[i]
        z = BTreeNode(y.leaf)
        node.children.insert(i + 1, z)
        node.keys.insert(i, y.keys[t - 1])
        z.keys = y.keys[t:(2 * t - 1)]
        y.keys = y.keys[0:t - 1]

        if not y.leaf:
            z.children = y.children[t:(2 * t)]
            y.children = y.children[0:t - 1]

    # Display the tree
    def display(self, node, level=0):
        print("Level", level, ":", node.keys)
        if not node.leaf:
            for child in node.children:
                self.display(child, level + 1)

# ---------- Main Program ----------
if __name__ == "__main__":
    print("=== B-Tree Implementation (Order 3) ===")
    btree = BTree(3)

    nums = input("Enter numbers to insert (comma separated): ").split(",")
    for n in nums:
        btree.insert(int(n.strip()))

    print("\nB-Tree structure:")
    btree.display(btree.root)

    key = int(input("\nEnter value to search: "))
    if btree.search(btree.root, key):
        print("✅ Found!")
    else:
        print("❌ Not found!")
